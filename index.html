<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Snake — Versión Avanzada (HTML + Canvas)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root{
  --bg:#071020;
  --panel:#071826;
  --accent:#22c55e;
  --muted:#94a3b8;
  --danger:#ef4444;
  --card: rgba(255,255,255,0.03);
}

html,body{
  height:100%;
  margin:0;
  background:var(--bg);
  font-family:Inter,Segoe UI,Roboto,system-ui,Arial;
  overflow-x:hidden;
}

/* Panel lateral fijo a la derecha, 20% más fino */
#ui {
  position: fixed;
  top: 18px;
  right: 18px;
  width: 288px; /* antes 360px */
  color:#cbd5e1;
  z-index: 10;
  max-height: 95vh;
  overflow-y:auto; /* scroll interno si hay mucho contenido */
}

#title{font-size:28px;color:var(--accent);font-weight:700;margin-bottom:6px}

.card{
  background:var(--panel);
  padding:14px;
  border-radius:12px;
  box-shadow:0 6px 18px rgba(2,6,23,0.6);
  margin-bottom:12px;
}

.muted{color:var(--muted);font-size:13px}

.btn{
  display:inline-block;
  padding:10px 14px;
  border-radius:10px;
  background:#0f1724;
  color:#fff;
  cursor:pointer;
  margin-right:8px;
  border:1px solid rgba(255,255,255,0.03);
}
.btn:active{transform:translateY(1px)}

.menu-item{
  padding:8px 12px;
  border-radius:8px;
  margin:6px 0;
  display:flex;
  align-items:center;
  justify-content:space-between;
}
.menu-item.selected{background:rgba(255,255,255,0.03);outline:1px solid rgba(255,255,255,0.02)}

.small{font-size:13px;color:var(--muted)}

canvas{
  border-radius:12px;
  display:block;
  background:#071022;
  box-shadow:0 10px 30px rgba(2,6,23,0.7);
}

/* Contenedor del canvas */
.wrap {
  margin-right: 0px; /* dejar espacio para el panel más fino */
  display:flex;
  flex-direction:row;
  gap:20px;
  align-items:flex-start;
  justify-content:center;
  padding:18px;
  box-sizing:border-box;
}

.footer{color:var(--muted);font-size:12px;margin-top:6px}

pre{white-space:pre-wrap;word-break:break-word;color:#9ca3af}

.kbd{
  background:#0b1220;
  border-radius:6px;
  padding:4px 8px;
  border:1px solid rgba(255,255,255,0.03);
  font-size:13px;
}

/* Banner simulado gris */
.ad-sim {
  background:#2d3748;
  color:#cbd5e1;
  padding:10px;
  border-radius:8px;
  text-align:center;
  font-size:14px;
  margin:10px auto;
  max-width:720px;
}

#ui {
  display: none !important;
}

</style>
</head>
<body>

  

<!-- Panel lateral derecho -->
<div id="ui">
  



  <div class="card">
    <button class="btn" id="btnPause">Pausa</button>
    <button class="btn" id="btnRestart">Reiniciar</button>
  </div> 

</div>




<!-- Banner superior REAL -->
<div style="text-align:center;margin-bottom:10px">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4708183492397858" crossorigin="anonymous"></script>
  <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4708183492397858" data-ad-slot="6859992512" data-ad-format="auto" data-full-width-responsive="true"></ins>
  <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>

<!-- Banner superior SIMULADO -->
<div class="ad-sim">[ Banner Superior Simulado en Gris ]</div>

<!-- Canvas del Splash animado (fondo) -->
<canvas id="splash" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;"></canvas>
<script>
const splashCanvas = document.getElementById('splash');
const splashCtx = splashCanvas.getContext('2d');

function resizeSplash() {
    splashCanvas.width = window.innerWidth;
    splashCanvas.height = window.innerHeight;
}
resizeSplash();
window.addEventListener('resize', resizeSplash);

function hexToRgb(hex) {
    hex = hex.replace('#','');
    const bigint = parseInt(hex,16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r,g,b];
}

// CONFIG
const numStars = 8000;
const numComets = 700;
const numNebulas = 2;
let focalLength = splashCanvas.width/2;

// ESTRELLAS
const stars = Array.from({length:numStars}, () => ({
    x: (Math.random()-0.5)*splashCanvas.width,
    y: (Math.random()-0.5)*splashCanvas.height,
    z: Math.random()*splashCanvas.width,
    color: ['#fff','#0ff','#f0f','#0f0','#ff0'][Math.floor(Math.random()*5)]
}));

// COMETAS
const comets = Array.from({length:numComets}, () => ({
    x: (Math.random()-0.5)*splashCanvas.width,
    y: (Math.random()-0.5)*splashCanvas.height,
    z: Math.random()*splashCanvas.width,
    length: Math.random()*100+50,
    color: ['#ff0','#0ff','#f0f','#0f0','#fff'][Math.floor(Math.random()*5)]
}));



function drawSplash() {

  
    splashCtx.fillStyle = '#000011';
    splashCtx.fillRect(0,0,splashCanvas.width,splashCanvas.height);

   

    focalLength = splashCanvas.width/2;

    // Estrellas
    stars.forEach(star => {
        star.z -= 30;
        if(star.z <= 0){
            star.x = (Math.random()-0.5)*splashCanvas.width;
            star.y = (Math.random()-0.5)*splashCanvas.height;
            star.z = splashCanvas.width;
            star.color = ['#fff','#0ff','#f0f','#0f0','#ff0'][Math.floor(Math.random()*5)];
        }
        const sx = (star.x / star.z)*focalLength + splashCanvas.width/2;
        const sy = (star.y / star.z)*focalLength + splashCanvas.height/2;
        const radius = (1 - star.z/splashCanvas.width)*3;

        splashCtx.beginPath();
        splashCtx.arc(sx, sy, radius, 0, Math.PI*2);
        splashCtx.fillStyle = star.color;
        splashCtx.fill();

        splashCtx.strokeStyle = star.color;
        splashCtx.beginPath();
        splashCtx.moveTo(sx, sy);
        splashCtx.lineTo(sx - (star.x/star.z)*15, sy - (star.y/star.z)*15);
        splashCtx.stroke();
    });

    // Cometas
    comets.forEach(comet => {
        comet.z -= 40;
        if(comet.z <= 0){
            comet.x = (Math.random()-0.5)*splashCanvas.width;
            comet.y = (Math.random()-0.5)*splashCanvas.height;
            comet.z = splashCanvas.width;
            comet.color = ['#ff0','#0ff','#f0f','#0f0','#fff'][Math.floor(Math.random()*5)];
        }
        const sx = (comet.x / comet.z)*focalLength + splashCanvas.width/2;
        const sy = (comet.y / comet.z)*focalLength + splashCanvas.height/2;

        splashCtx.strokeStyle = comet.color;
        splashCtx.lineWidth = 2;
        splashCtx.beginPath();
        splashCtx.moveTo(sx, sy);
        splashCtx.lineTo(sx - (comet.x/comet.z)*comet.length, sy - (comet.y/comet.z)*comet.length);
        splashCtx.stroke();
    });

    requestAnimationFrame(drawSplash);
}



drawSplash();



let splashTimeout = setTimeout(() => {
    splashCanvas.style.display = 'none';
    initMenu(); // en vez de mostrar difficultyMenu
}, 30000);

function startAfterSplash() {
    clearTimeout(splashTimeout);
    splashCanvas.style.display = 'none';
    initMenu();
}


// Click o teclado para saltar el splash
splashCanvas.addEventListener;
window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
        startAfterSplash();
    }
});

// ---------- Botones del menú ----------
const difficultyButtons = document.querySelectorAll('.difficulty-btn');
difficultyButtons.forEach((btn, index) => {
    btn.addEventListener('click', () => {
        difficultyMenu.style.display = 'none'; // ocultar menú
        engine.menuIndex = index;             // asignar dificultad al menú
        engine.difficultyIndex = index;       // sincronizar con el engine
        startNewGame(index);                  // iniciar el juego
    });
});

</script>


<!-- Canvas del Juego -->
<div style="display:flex;justify-content:center;align-items:flex-start;">
  <div class="wrap">
    <canvas id="game" width="720" height="480"></canvas>
  </div>
</div>

</body>
</html>


    <!-- UI -->
    <div id="ui">
      <div class="card">
        <div id="title">Snake — Pro</div>
        <div class="muted">Usá flechas o WASD para navegar el menú y mover la serpiente. Enter para confirmar.</div>
      </div>

      <div class="card" id="menuCard">
        <div style="font-weight:700;margin-bottom:6px">Menú</div>
        <div id="menuOptions">

        </div>
        <div style="margin-top:10px;">
          <button class="btn" id="btnStart">Iniciar juego</button>
          <button class="btn" id="btnTutorial">Tutorial</button>
        </div>
      </div>

      <div class="card" id="statsCard">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:700" id="labelMode">Modo: Normal</div>
            <div class="muted" id="labelInfo">Puntaje, vidas y velocidad</div>
          </div>
          <div style="text-align:right">
            <div style="font-weight:800;font-size:20px" id="scoreLabel">0</div>
            <div class="small">Puntos</div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0">

        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <div class="small">Vidas: <span id="livesLabel">1</span></div>
          <div class="small">Comidas: <span id="foodCount">0</span></div>
          <div class="small">Vel (ms): <span id="tickLabel">100</span></div>
        </div>
      </div>

      <div class="card" id="controlsCard">
        <div style="font-weight:700">Opciones rápidas</div>
        <div style="margin-top:8px" class="small">
          <div>- Espacio: Pausa/Continuar</div>
          <div>- Enter: Seleccionar en menú / Reiniciar tras Game Over</div>
          <div>- Esc: Volver al menú</div>
        </div>
      </div>

      <div class="card" id="credits">
        <div style="font-weight:700">Detalles</div>
        <div class="muted small" style="margin-top:8px">
          - Comida roja (crece)<br>
          - Veneno violeta (pierde juego)<br>
          - Corazón amarillo (da vida extra)<br>
          - Obstáculos grises (matan)<br>
        </div>
      </div>
    </div>
  </div>
</div>

<script>

 class Particle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 2 + 1; // tamaño de partícula
        this.alpha = 1;

        // 🔹 colores aleatorios
        const colors = [
            '#ff0000', '#ffd700', '#00ffff', '#ccff00', 
            '#ff66cc', '#9400d3', '#ff8000', '#40e0d0'
        ];
        this.color = colors[Math.floor(Math.random() * colors.length)];

        // 🔹 dispersión circular
        const angle = Math.random() * Math.PI * 2; // ángulo 0-360°
        const speed = Math.random() * 5 + 2;       // velocidad radial
        this.speedX = Math.cos(angle) * speed;
        this.speedY = Math.sin(angle) * speed;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.alpha -= 0.02;
    }

    draw(ctx) {
        ctx.fillStyle = this.hexToRgba(this.color, this.alpha);
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }

    hexToRgba(hex, alpha) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r},${g},${b},${alpha})`;
    }
}

let particles = [];

function triggerParticles(x, y) {
    for (let i = 0; i < 500; i++) {
        particles.push(new Particle(x, y));
    }
}

function updateParticles(ctx) {
    particles.forEach((p, i) => {
        p.update();
        p.draw(ctx);
        if (p.alpha <= 0) particles.splice(i, 1);
    });
}
/* -----------------------------
   GAME: Snake en Canvas (completo)
   - Menú navegable con flechas/WASD + Enter
   - 4 modos (basic,easy,normal,hard)
   - Obstáculos, veneno, corazón
   - Cambio de color cada 5 comidas (interpolación segura)
   - Controles: Flechas/WASD, Espacio pausa, Enter seleccionar
   - Todo en JS puro (sin librerías)
   ----------------------------- */

/* ---------- Configuración general ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Responsive canvas (wide-friendly): ocupará un área grande pero manteniendo proporción
function resizeCanvas() {
  // Queremos un área wide con límite máximo:
  const maxWidth = Math.min(window.innerWidth - 0, 1400); // deja espacio para UI
  const width = Math.max(480, maxWidth);
  const aspect = 16/8;
  const height = Math.round(width / aspect);

  canvas.width = width;
  canvas.height = height;
}
resizeCanvas();
window.addEventListener('resize', () => { resizeCanvas(); engine && engine.onResize && engine.onResize(); });

/* ---------- Dificultades ---------- */
const DIFFICULTIES = [
  { name: 'Básico', speedMs: 150, numObstacles: 0, poisonChance: 0.00, extraLifeChance: 0.00 },
  { name: 'Fácil',  speedMs: 140, numObstacles: 6, poisonChance: 0.03, extraLifeChance: 0.03 },
  { name: 'Normal', speedMs: 110, numObstacles: 10, poisonChance: 0.08, extraLifeChance: 0.02 },
  { name: 'Difícil',speedMs: 85,  numObstacles: 16, poisonChance: 0.16, extraLifeChance: 0.01 },
  { name: 'Extremo',speedMs: 70,  numObstacles: 20, poisonChance: 0.25, extraLifeChance: 0.005 }
];

/* ---------- Colores ---------- */
const snakeColors = [
  "#FFD700", // Dorado brillante
  "#FF0000", // Rojo fuerte
  "#FF7F00", // Naranja vivo
  "#ADFF2F", // Verde limón explosivo
  "#00FF7F", // Verde esmeralda fluorescente
  "#00BFFF", // Celeste intenso
  "#1E90FF", // Azul brillante
  "#8A2BE2", // Violeta eléctrico
  "#FF00FF", // Fucsia neón
  "#FF1493"  // Rosa fuerte
];


 // 5 colores
const foodColor = '#f43f5e'; // rojo
const poisonColor = '#9b5de5'; // violeta
const heartColor = '#ffd166'; // amarillo
const obstacleColor = '#64748b';
const gridBg = '#000000';

/* ---------- Motor del juego ---------- */
const engine = {
  // grid variables (se recalculan cuando se redimensiona)
  cell: 24, cols: 30, rows: 18,

  // state
  running: false,
  inMenu: true,
  paused: false,
  gameOver: false,
  difficultyIndex: 2, // default Normal
  score: 0,
  foodEaten: 0,
  lives: 1,
  colorIndex: 0,
  pausedMenu: false,
pauseMenuIndex: 0,


  // game objects
  snake: [],
  dir: {x:1,y:0},
  nextDir: {x:1,y:0},
  food: null,
  poison: null,
  heart: null,
  obstacles: [],

  // timing
  tickMs: 110,
  tickAccumulator: 0,
  lastTime: null,

  // menu selection
  menuIndex: 2, // default selected
};

/* ---------- Utilidades ---------- */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function randInt(max){ return Math.floor(Math.random()*max); }
function posEq(a,b){ return a.x===b.x && a.y===b.y; }
function hexToRgb(hex){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  return { r: (bigint>>16)&255, g: (bigint>>8)&255, b: bigint&255 };
}
function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
function mixHex(c1, c2, t){
  const a = hexToRgb(c1), b = hexToRgb(c2);
  return '#' + ((1<<24) + (lerp(a.r,b.r,t)<<16) + (lerp(a.g,b.g,t)<<8) + lerp(a.b,b.b,t)).toString(16).slice(1);
}

/* ---------- Initializers ---------- */
function setupGrid(){
  // choose cell size so grid fits canvas with margin
  // prefer at least 16 cells tall
  const minCell = 14;
  const maxCell = 36;
  const desiredCols = Math.floor(canvas.width / 24);
  const cell = clamp(Math.floor(canvas.width / desiredCols), minCell, maxCell);
  engine.cell = cell;
  engine.cols = Math.floor(canvas.width / cell);
  engine.rows = Math.floor(canvas.height / cell);
}
setupGrid();

/* ---------- Core functions ---------- */
function initMenu(){
  engine.inMenu = true;
  engine.running = false;
  engine.paused = false;
  engine.gameOver = false;
  engine.menuIndex = engine.difficultyIndex;
  renderUI(); // highlight selection
}



function startNewGame(difficultyIndex){
  // set difficulty
  engine.difficultyIndex = difficultyIndex;
  const diff = DIFFICULTIES[difficultyIndex];
  engine.tickMs = diff.speedMs;
  engine.score = 0;
  engine.foodEaten = 0;
  engine.lives = 1;
  engine.colorIndex = 0;

 

  // (re)setup grid for current canvas size
  setupGrid();

  // center start position
  const startX = Math.floor(engine.cols/2);
  const startY = Math.floor(engine.rows/2);

  engine.snake = [
    {x:startX, y:startY},
    {x:startX-1, y:startY},
    {x:startX-2, y:startY}
  ];
  engine.dir = {x:1,y:0};
  engine.nextDir = {x:1,y:0};
  engine.obstacles = Array.from({length:diff.numObstacles}, () => randomFreeCell());
  engine.food = randomFreeCell();
  engine.poison = Math.random() < diff.poisonChance ? randomFreeCell() : null;

  engine.heart = null;
  engine.lastTime = performance.now();
  engine.tickAccumulator = 0;


  engine.running = true;
  engine.inMenu = false;
  engine.paused = false;
  engine.gameOver = false;
  engine.lastTime = performance.now();
  engine.tickAccumulator = 0;
  renderUI();
}

/* pick a free cell not overlapping snake/obstacles/food/etc */
function randomFreeCell(){
  let p;
  do {
    p = { x: randInt(engine.cols), y: randInt(engine.rows) };
  } while (
    engine.snake.some(s=>posEq(s,p)) ||
    engine.obstacles.some(o=>posEq(o,p)) ||
    (engine.food && posEq(engine.food,p)) ||
    (engine.poison && posEq(engine.poison,p)) ||
    (engine.heart && posEq(engine.heart,p))
  );
  return p;
}

/* ---------- Game update logic (grid ticks) ---------- */
function tick(){
  if(!engine.running || engine.paused || engine.gameOver) return;

  // aplicar dirección
  engine.dir = engine.nextDir;
  const head = { x: engine.snake[0].x + engine.dir.x, y: engine.snake[0].y + engine.dir.y };

  // wrap-around
  if(head.x < 0) head.x = engine.cols - 1;
  if(head.x >= engine.cols) head.x = 0;
  if(head.y < 0) head.y = engine.rows - 1;
  if(head.y >= engine.rows) head.y = 0;

  // colisión con sí mismo o con obstáculos
  if(engine.snake.some(s => posEq(s, head)) || engine.obstacles.some(o => posEq(o, head))){
    engine.lives -= 1;
    if(engine.lives <= 0){
      engine.gameOver = true;
      engine.running = false;
    } else {
      // respawn snake en el centro, mantener score
      const sx = Math.floor(engine.cols/2), sy = Math.floor(engine.rows/2);
      engine.snake = [{x:sx,y:sy},{x:sx-1,y:sy},{x:sx-2,y:sy}];
      engine.dir = {x:1,y:0};
      engine.nextDir = {x:1,y:0};
    }
    renderUI();
    return;
  }

  const ateFood = engine.food && posEq(head, engine.food);
  const atePoison = engine.poison && posEq(head, engine.poison);

  engine.snake.unshift(head);
  if(!ateFood) engine.snake.pop();

  if(ateFood){
    engine.score++;
    engine.foodEaten++;

    // 🔥 Explosión de partículas en el centro de la celda de comida
    triggerParticles(
      engine.food.x * engine.cell + engine.cell / 2,
      engine.food.y * engine.cell + engine.cell / 2
    );

    // cada 5 comidas aumenta la velocidad y cambia color
    if(engine.score % 5 === 0){
      engine.tickMs *= 0.95;
      engine.colorIndex = (engine.colorIndex + 1) % snakeColors.length;
    }

    // respawn food
    engine.food = randomFreeCell();

    // chance de generar veneno según dificultad
    const diff = DIFFICULTIES[engine.difficultyIndex];
    if(Math.random() < diff.poisonChance) engine.poison = randomFreeCell();

    // ---------- Heart logic ----------
    // chance de aparecer corazón al comer
    if(!engine.heart && Math.random() < diff.extraLifeChance){
        engine.heart = {
            floatX: Math.random() * (canvas.width - engine.cell) + engine.cell/2,
            floatY: Math.random() * (canvas.height - engine.cell) + engine.cell/2,
            dx: (Math.random() * 2 - 1) * 4.5,
            dy: (Math.random() * 2 - 1) * 4.5,
            radius: engine.cell * 0.35
        };
    }

    renderUI();
}





if(engine.heart){
    // mover corazón
    engine.heart.floatX += engine.heart.dx;
    engine.heart.floatY += engine.heart.dy;

    // rebote en bordes
    if(engine.heart.floatX - engine.heart.radius < 0 || engine.heart.floatX + engine.heart.radius > canvas.width)
      engine.heart.dx *= -1;
    if(engine.heart.floatY - engine.heart.radius < 0 || engine.heart.floatY + engine.heart.radius > canvas.height)
      engine.heart.dy *= -1;

    // cambio de dirección aleatorio (1 de cada 60 ticks aprox)
    if(Math.random() < 1/60){
      engine.heart.dx = (Math.random() * 2 - 1) * 4.5;
      engine.heart.dy = (Math.random() * 2 - 1) * 4.5;
    }

    // colisión con la serpiente (cabeza)
    const headPxX = (head.x + 0.5) * engine.cell;
    const headPxY = (head.y + 0.5) * engine.cell;
    const dx = engine.heart.floatX - headPxX;
    const dy = engine.heart.floatY - headPxY;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if(dist < engine.heart.radius + engine.cell/2){
      engine.lives = Math.min(engine.lives + 1, 3);
      engine.heart = null;
      renderUI();
    }
}


  if(atePoison){
    engine.gameOver = true;
    engine.running = false;
    renderUI();
    return;
  }
}


/* ---------- Main render ---------- */
function draw(){
  // clear
  ctx.fillStyle = gridBg;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // grid (optional subtle)
  // draw obstacles
  const cell = engine.cell;
  ctx.save();
  ctx.translate(0,0);

  // Draw obstacles
  ctx.fillStyle = obstacleColor;
  engine.obstacles.forEach(o => {
    ctx.fillRect(o.x*cell, o.y*cell, cell, cell);
  });

  // Draw food (single)
  if(engine.food){
    ctx.fillStyle = foodColor;
    const cx = engine.food.x*cell + cell/2, cy = engine.food.y*cell + cell/2, r = cell*0.36;
    roundFillCircle(cx, cy, r);
  }

  // Poison
  if(engine.poison){
    ctx.fillStyle = poisonColor;
    roundFillCircle(engine.poison.x*cell + cell/2, engine.poison.y*cell + cell/2, cell*0.30);
  }

  // Heart
  // ---------- Draw Heart (solo) ----------
if(engine.heart){
    ctx.fillStyle = heartColor;
    ctx.beginPath();
    ctx.arc(engine.heart.floatX, engine.heart.floatY, engine.heart.radius, 0, Math.PI*2);
    ctx.fill();

  // movimiento oscilante constante
  engine.frameCount = (engine.frameCount || 0) + 1; // contador de frames

  const t = engine.frameCount / 10; // ajusta velocidad del movimiento
  const heartOscX = Math.sin(t) * 0.25; // amplitud horizontal
  const heartOscY = Math.cos(t) * 0.25; // amplitud vertical

  // calculamos posición con offset +0.5 para centrar en la celda3
  const hx = (engine.heart.x + 0.5 + heartOscX) * engine.cell;
  const hy = (engine.heart.y + 0.5 + heartOscY) * engine.cell;

  roundFillCircle(hx, hy, engine.cell * 0.28);

}


  // Snake color interpolation: progress within 5
  const nextIdx = (engine.colorIndex + 1) % snakeColors.length;
  const t = (engine.score % 5) / 5;
  const snakeColorHex = mixHex(snakeColors[engine.colorIndex], snakeColors[nextIdx], t);

  // Draw snake
  ctx.fillStyle = snakeColorHex;
  engine.snake.forEach((seg, i) => {
    // slight rounded rect for style
    roundRect(ctx, seg.x*cell+1, seg.y*cell+1, cell-2, cell-2, Math.max(4, cell*0.12));
  });

  // Score & small HUD on canvas
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(6,6,170,38);
  ctx.fillStyle = '#ffffff';
  ctx.font = `${12 + Math.round(cell*0.06)}px monospace`;
  ctx.fillText(`Puntos: ${engine.score}`, 14, 24);
  ctx.fillText(`Vidas: ${engine.lives}`, 110, 24);

  // === Dibujar partículas SIEMPRE al final ===
updateParticles(ctx);

ctx.restore();

  // paused / menu / gameover overlay
    // ---------- Overlays ----------
  if(engine.inMenu){
    drawMenuOverlay();
  } else if(engine.pausedMenu){
    drawPauseMenuOverlay();   // 👈 nuevo
  } else if(engine.paused){
    drawCenteredText('PAUSA', 'Presiona Espacio para continuar');
  } else if(engine.gameOver){
  drawCenteredText('GAME OVER', 'Space: Reiniciar · Esc: Menú');
}



  ctx.restore();
}

function roundFillCircle(x,y,r){
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.fill();
}

/* ---------- Overlay / Menu rendering on canvas ---------- */
function drawMenuOverlay(){
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.font = `${Math.round(engine.cell * 1.0)}px monospace`;
  ctx.fillText('Snake — Selecciona modo', canvas.width/2, canvas.height/2 - 60);
  ctx.font = `${Math.round(engine.cell * 0.6)}px monospace`;
  for(let i=0;i<DIFFICULTIES.length;i++){
    const text = `${i===engine.menuIndex ? '▶ ' : '   '}${DIFFICULTIES[i].name}`;
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 10 + i*30);
  }
  ctx.textAlign = 'start';
}

/* ---------- Helpers UI ---------- */
function renderUI(){
  document.getElementById('scoreLabel').innerText = engine.score;
  document.getElementById('foodCount').innerText = engine.foodEaten;
  document.getElementById('livesLabel').innerText = engine.lives;
  document.getElementById('tickLabel').innerText = engine.tickMs || DIFFICULTIES[engine.difficultyIndex].speedMs;
  document.getElementById('labelMode').innerText = 'Modo: ' + DIFFICULTIES[engine.difficultyIndex].name;

  // highlight menu items
  const items = document.querySelectorAll('#menuOptions .menu-item');
  items.forEach(it => it.classList.remove('selected'));
  const sel = document.querySelector(`#menuOptions .menu-item[data-index="${engine.menuIndex}"]`);
  if(sel) sel.classList.add('selected');
}

/* ---------- Input handling (keyboard + mouse) ---------- */
const keys = {};
window.addEventListener('keydown', (e) => {
  if(keys[e.code]) return; // evitar repeticiones
  keys[e.code] = true;

  // ---------- Escape: menú de pausa ----------
  if(e.code === 'Escape'){
    if(!engine.inMenu && !engine.gameOver){
      // abrir/cerrar menú de pausa
      engine.pausedMenu = !engine.pausedMenu;
      engine.paused = engine.pausedMenu; // pausamos el juego
      engine.pauseMenuIndex = 0; // opción inicial
      renderUI();
    } else if(engine.inMenu){
      // si ya está en menú principal, reinicia
      engine.running = false;
      initMenu();
    }
    e.preventDefault();
    return;
  }

  if(e.code === 'Space'){
    if(engine.inMenu || engine.pausedMenu){
        engine.paused = !engine.paused;
        renderUI();
    } else if(engine.gameOver){
        startNewGame(engine.difficultyIndex);
    }
    e.preventDefault();
    return;
}



  // ---------- Navegación menú principal ----------
  if(engine.inMenu){
    if(e.code === 'ArrowUp' || e.code === 'KeyW') {
      engine.menuIndex = (engine.menuIndex - 1 + DIFFICULTIES.length) % DIFFICULTIES.length;
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'ArrowDown' || e.code === 'KeyS') {
      engine.menuIndex = (engine.menuIndex + 1) % DIFFICULTIES.length;
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'Enter') {
      startNewGame(engine.menuIndex);
      e.preventDefault();
      return;
    }
  }

  // ---------- Navegación menú de pausa ----------
  if(engine.pausedMenu){
    if(e.code === 'ArrowUp' || e.code === 'KeyW'){
      engine.pauseMenuIndex = (engine.pauseMenuIndex - 1 + 3) % 3; // 3 opciones
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'ArrowDown' || e.code === 'KeyS'){
      engine.pauseMenuIndex = (engine.pauseMenuIndex + 1) % 3;
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'Enter'){
      if(engine.pauseMenuIndex === 0){ 
        // continuar
        engine.pausedMenu = false;
        engine.paused = false;
      }
      if(engine.pauseMenuIndex === 1){ 
        // cambiar modo (lleva al menú principal)
        engine.pausedMenu = false;
        engine.inMenu = true;
        initMenu();
      }
      if(engine.pauseMenuIndex === 2){ 
        // volver al menú principal
        engine.pausedMenu = false;
        engine.inMenu = true;
        initMenu();
      }
      renderUI();
      e.preventDefault();
      return;
    }
  }

  // ---------- Controles en Game Over ----------
// ---------- Controles en Game Over ----------
if(engine.gameOver){
  if(e.code === 'Space'){ // <--- cambiamos Enter por Space
    // reiniciar con misma dificultad
    startNewGame(engine.difficultyIndex);
    e.preventDefault();
    return;
  }
  if(e.code === 'Escape'){
    // volver al menú principal
    engine.inMenu = true;
    engine.gameOver = false;
    initMenu();
    e.preventDefault();
    return;
  }
}



  // ---------- Controles dentro del juego ----------
  if(!engine.inMenu && !engine.gameOver && !engine.pausedMenu){
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') {
      if(engine.dir.x !== 1) engine.nextDir = {x:-1,y:0};
    }
    if(e.code === 'ArrowRight' || e.code === 'KeyD') {
      if(engine.dir.x !== -1) engine.nextDir = {x:1,y:0};
    }
    if(e.code === 'ArrowUp' || e.code === 'KeyW') {
      if(engine.dir.y !== 1) engine.nextDir = {x:0,y:-1};
    }
    if(e.code === 'ArrowDown' || e.code === 'KeyS') {
      if(engine.dir.y !== -1) engine.nextDir = {x:0,y:1};
    }
    if(e.code === 'Enter' && engine.gameOver){
      // reinicio con misma dificultad
      startNewGame(engine.difficultyIndex);
    }
  }
});

window.addEventListener('keyup', (e) => { keys[e.code] = false; });

/* ---------- Mouse / UI bindings ---------- */
document.getElementById('btnStart').addEventListener('click', () => {
  startNewGame(engine.menuIndex);
});
document.getElementById('btnTutorial').addEventListener('click', () => {
  alert('Controles: Flechas o WASD para mover, Espacio para pausar, Enter para seleccionar. Evitá el veneno y los obstáculos. ¡Suerte!');
});
document.getElementById('btnPause').addEventListener('click', () => {
  if(engine.inMenu || engine.pausedMenu) return;
  engine.paused = !engine.paused;
});
document.getElementById('btnRestart').addEventListener('click', () => {
  startNewGame(engine.difficultyIndex);
});
document.querySelectorAll('#menuOptions .menu-item').forEach(it=>{
  it.addEventListener('click', () => {
    const idx = parseInt(it.dataset.index,10);
    engine.menuIndex = idx;
    renderUI();
  });
  it.addEventListener('dblclick', () => {
    const idx = parseInt(it.dataset.index,10);
    startNewGame(idx);
  });
});

/* ---------- Game loop using requestAnimationFrame + accumulator ---------- */
function gameLoopFrame(now){
  if(!engine.lastTime) engine.lastTime = now;
  const dt = now - engine.lastTime;
  engine.lastTime = now;

  if(engine.running && !engine.paused && !engine.inMenu && !engine.gameOver){
    engine.tickAccumulator += dt;
    while(engine.tickAccumulator >= engine.tickMs){
      tick();
      engine.tickAccumulator -= engine.tickMs;
    }
  }

  draw();
  requestAnimationFrame(gameLoopFrame);
}
requestAnimationFrame(gameLoopFrame);

/* ---------- Pause Menu Overlay ---------- */
function drawPauseMenuOverlay(){
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.font = `${Math.round(engine.cell * 1.0)}px monospace`;
  ctx.fillText('PAUSA', canvas.width/2, canvas.height/2 - 60);

  const options = ['Continuar', 'Cambiar Modo', 'Volver al Menú'];
  ctx.font = `${Math.round(engine.cell * 0.6)}px monospace`;

  for(let i=0;i<options.length;i++){
    const prefix = (i===engine.pauseMenuIndex) ? '▶ ' : '   ';
    ctx.fillText(prefix + options[i], canvas.width/2, canvas.height/2 - 10 + i*30);
  }
  ctx.textAlign = 'start';
}


/* ---------- Resize handler helper for engine ---------- */
engine.onResize = function(){
  // recompute grid so things still line up
  setupGrid();
  // ensure obstacles/food are valid
  if(engine.obstacles.length === 0 && engine.running){
    const diff = DIFFICULTIES[engine.difficultyIndex];
    engine.obstacles = Array.from({length:diff.numObstacles}, () => randomFreeCell());
  }
};

/* ---------- Helper: draw centered text ---------- */
function drawCenteredText(main, sub){
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(canvas.width*0.18, canvas.height*0.38, canvas.width*0.64, canvas.height*0.22);
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.font = `${Math.round(engine.cell * 1.0)}px monospace`;
  ctx.fillText(main, canvas.width/2, canvas.height/2 - 8);
  ctx.font = `${Math.round(engine.cell * 0.5)}px monospace`;
  ctx.fillText(sub, canvas.width/2, canvas.height/2 + 20);
}

/* ---------- Boot: show menu ---------- */
initMenu();
renderUI();

/* ---------- Small polishing / safety ---------- */
// Make sure canvas is focusable for keyboard when clicked
canvas.tabIndex = 1000;
canvas.style.outline = 'none';
canvas.addEventListener('click', ()=>{ canvas.focus(); });

</script>
</body>
</html>

