<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Snake — Versión Avanzada (HTML + Canvas)</title>
<meta name="google-adsense-account" content="ca-pub-4708183492397858">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root{
  --bg:#071020;
  --panel:#071826;
  --accent:#22c55e;
  --muted:#94a3b8;
  --danger:#ef4444;
  --card: rgba(255,255,255,0.03);
}

html,body{
  height:100%;
  margin:0;
  background:var(--bg);
  font-family:Inter,Segoe UI,Roboto,system-ui,Arial;
  overflow-x:hidden;
}

/* Panel lateral fijo a la derecha, 20% más fino */
#ui {
  position: fixed;
  top: 18px;
  right: 18px;
  width: 288px; /* antes 360px */
  color:#cbd5e1;
  z-index: 10;
  max-height: 95vh;
  overflow-y:auto; /* scroll interno si hay mucho contenido */
}

#title{font-size:28px;color:var(--accent);font-weight:700;margin-bottom:6px}

.card{
  background:var(--panel);
  padding:14px;
  border-radius:12px;
  box-shadow:0 6px 18px rgba(2,6,23,0.6);
  margin-bottom:12px;
}

.muted{color:var(--muted);font-size:13px}

.btn{
  display:inline-block;
  padding:10px 14px;
  border-radius:10px;
  background:#0f1724;
  color:#fff;
  cursor:pointer;
  margin-right:8px;
  border:1px solid rgba(255,255,255,0.03);
}
.btn:active{transform:translateY(1px)}

.menu-item{
  padding:8px 12px;
  border-radius:8px;
  margin:6px 0;
  display:flex;
  align-items:center;
  justify-content:space-between;
}
.menu-item.selected{background:rgba(255,255,255,0.03);outline:1px solid rgba(255,255,255,0.02)}

.small{font-size:13px;color:var(--muted)}

canvas{
  border-radius:12px;
  display:block;
  background:#071022;
  box-shadow:0 10px 30px rgba(2,6,23,0.7);
}

/* Contenedor del canvas */
.wrap {
  margin-right: 0px; /* dejar espacio para el panel más fino */
  display:flex;
  flex-direction:row;
  gap:20px;
  align-items:flex-start;
  justify-content:center;
  padding:18px;
  box-sizing:border-box;
}

.footer{color:var(--muted);font-size:12px;margin-top:6px}

pre{white-space:pre-wrap;word-break:break-word;color:#9ca3af}

.kbd{
  background:#0b1220;
  border-radius:6px;
  padding:4px 8px;
  border:1px solid rgba(255,255,255,0.03);
  font-size:13px;
}

/* Banner simulado gris */
.ad-sim {
  background:#2d3748;
  color:#cbd5e1;
  padding:10px;
  border-radius:8px;
  text-align:center;
  font-size:14px;
  margin:10px auto;
  max-width:720px;
}

#ui {
  display: none !important;
}

</style>
</head>
<body>

  

<!-- Panel lateral derecho -->
<div id="ui">
  



  <div class="card">
    <button class="btn" id="btnPause">Pausa</button>
    <button class="btn" id="btnRestart">Reiniciar</button>
  </div> 

</div>




<!-- Banner superior REAL -->
<div style="text-align:center;margin-bottom:10px">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4708183492397858" crossorigin="anonymous"></script>
  <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4708183492397858" data-ad-slot="6859992512" data-ad-format="auto" data-full-width-responsive="true"></ins>
  <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>

<!-- Banner superior SIMULADO -->
<div class="ad-sim">[ Banner Superior Simulado en Gris ]</div>

<!-- Canvas del Splash animado (fondo) -->
<canvas id="splash" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;"></canvas>
<script>
const splashCanvas = document.getElementById('splash');
const splashCtx = splashCanvas.getContext('2d');

function resizeSplash() {
    splashCanvas.width = window.innerWidth;
    splashCanvas.height = window.innerHeight;
}
resizeSplash();
window.addEventListener('resize', resizeSplash);

function hexToRgb(hex) {
    hex = hex.replace('#','');
    const bigint = parseInt(hex,16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r,g,b];
}

// CONFIG
const numStars = 8000;
const numComets = 700;
const numNebulas = 2;
let focalLength = splashCanvas.width/2;

// ESTRELLAS
const stars = Array.from({length:numStars}, () => ({
    x: (Math.random()-0.5)*splashCanvas.width,
    y: (Math.random()-0.5)*splashCanvas.height,
    z: Math.random()*splashCanvas.width,
    color: ['#fff','#0ff','#f0f','#0f0','#ff0'][Math.floor(Math.random()*5)]
}));

// COMETAS
const comets = Array.from({length:numComets}, () => ({
    x: (Math.random()-0.5)*splashCanvas.width,
    y: (Math.random()-0.5)*splashCanvas.height,
    z: Math.random()*splashCanvas.width,
    length: Math.random()*100+50,
    color: ['#ff0','#0ff','#f0f','#0f0','#fff'][Math.floor(Math.random()*5)]
}));



function drawSplash() {

  
    splashCtx.fillStyle = '#000011';
    splashCtx.fillRect(0,0,splashCanvas.width,splashCanvas.height);

   

    focalLength = splashCanvas.width/2;

    // Estrellas
    stars.forEach(star => {
        star.z -= 30;
        if(star.z <= 0){
            star.x = (Math.random()-0.5)*splashCanvas.width;
            star.y = (Math.random()-0.5)*splashCanvas.height;
            star.z = splashCanvas.width;
            star.color = ['#fff','#0ff','#f0f','#0f0','#ff0'][Math.floor(Math.random()*5)];
        }
        const sx = (star.x / star.z)*focalLength + splashCanvas.width/2;
        const sy = (star.y / star.z)*focalLength + splashCanvas.height/2;
        const radius = (1 - star.z/splashCanvas.width)*3;

        splashCtx.beginPath();
        splashCtx.arc(sx, sy, radius, 0, Math.PI*2);
        splashCtx.fillStyle = star.color;
        splashCtx.fill();

        splashCtx.strokeStyle = star.color;
        splashCtx.beginPath();
        splashCtx.moveTo(sx, sy);
        splashCtx.lineTo(sx - (star.x/star.z)*15, sy - (star.y/star.z)*15);
        splashCtx.stroke();
    });

    // Cometas
    comets.forEach(comet => {
        comet.z -= 40;
        if(comet.z <= 0){
            comet.x = (Math.random()-0.5)*splashCanvas.width;
            comet.y = (Math.random()-0.5)*splashCanvas.height;
            comet.z = splashCanvas.width;
            comet.color = ['#ff0','#0ff','#f0f','#0f0','#fff'][Math.floor(Math.random()*5)];
        }
        const sx = (comet.x / comet.z)*focalLength + splashCanvas.width/2;
        const sy = (comet.y / comet.z)*focalLength + splashCanvas.height/2;

        splashCtx.strokeStyle = comet.color;
        splashCtx.lineWidth = 2;
        splashCtx.beginPath();
        splashCtx.moveTo(sx, sy);
        splashCtx.lineTo(sx - (comet.x/comet.z)*comet.length, sy - (comet.y/comet.z)*comet.length);
        splashCtx.stroke();
    });

    const text = 'Press Space to Start';
const fontSize = Math.min(48, splashCanvas.height / 12);

// Fuente más elegante y profesional
splashCtx.font = `${fontSize}px "Arial Black", Arial, sans-serif`;
splashCtx.textAlign = 'center';
splashCtx.textBaseline = 'middle';

// Relleno semi-transparente más sutil
splashCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
splashCtx.fillText(text, splashCanvas.width / 2, splashCanvas.height / 2);

// Borde más fino
splashCtx.lineWidth = 2; // borde más delgado
splashCtx.strokeStyle = '#FFD700'; // amarillo dorado
splashCtx.strokeText(text, splashCanvas.width / 2, splashCanvas.height / 2);




    requestAnimationFrame(drawSplash);
}

drawSplash();

let splashTimeout = setTimeout(() => {
    splashCanvas.style.display = 'none';
    initMenu(); // en vez de mostrar difficultyMenu
    removeSplashListener(); // removemos listener cuando el splash termina solo
}, 30000);

function startAfterSplash() {
    clearTimeout(splashTimeout);
    splashCanvas.style.display = 'none';
    initMenu();
    removeSplashListener(); // removemos listener al saltar el splash
}

// listener temporal solo para el splash
function onSpaceSplash(e) {
    if (e.code === 'Space') {
        startAfterSplash();
    }
}

function removeSplashListener() {
    window.removeEventListener('keydown', onSpaceSplash);
}

// agregamos el listener temporal
window.addEventListener('keydown', onSpaceSplash);


// ---------- Botones del menú ----------
const difficultyButtons = document.querySelectorAll('.difficulty-btn');
difficultyButtons.forEach((btn, index) => {
    btn.addEventListener('click', () => {
        difficultyMenu.style.display = 'none'; // ocultar menú
        engine.menuIndex = index;             // asignar dificultad al menú
        engine.difficultyIndex = index;       // sincronizar con el engine
        startNewGame(index);                  // iniciar el juego
    });
});

</script>


<!-- Canvas del Juego -->
<div style="display:flex;justify-content:center;align-items:flex-start;">
  <div class="wrap">
    <canvas id="game" width="720" height="480"></canvas>
  </div>
</div>

</body>
</html>


    <!-- UI -->
    <div id="ui">
      <div class="card">
        <div id="title">Snake — Pro</div>
        <div class="muted">Usá flechas o WASD para navegar el menú y mover la serpiente. Enter para confirmar.</div>
      </div>

      <div class="card" id="menuCard">
        <div style="font-weight:700;margin-bottom:6px">Menú</div>
        <div id="menuOptions">

        </div>
        <div style="margin-top:10px;">
          <button class="btn" id="btnStart">Iniciar juego</button>
          <button class="btn" id="btnTutorial">Tutorial</button>
        </div>
      </div>

      <div class="card" id="statsCard">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:700" id="labelMode">Modo: Normal</div>
            <div class="muted" id="labelInfo">Puntaje, vidas y velocidad</div>
          </div>
          <div style="text-align:right">
            <div style="font-weight:800;font-size:20px" id="scoreLabel">0</div>
            <div class="small">Puntos</div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0">

        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <div class="small">Vidas: <span id="livesLabel">1</span></div>
          <div class="small">Comidas: <span id="foodCount">0</span></div>
          <div class="small">Vel (ms): <span id="tickLabel">100</span></div>
        </div>
      </div>

      <div class="card" id="controlsCard">
        <div style="font-weight:700">Opciones rápidas</div>
        <div style="margin-top:8px" class="small">
          <div>- Espacio: Pausa/Continuar</div>
          <div>- Enter: Seleccionar en menú / Reiniciar tras Game Over</div>
          <div>- Esc: Volver al menú</div>
        </div>
      </div>

      <div class="card" id="credits">
        <div style="font-weight:700">Detalles</div>
        <div class="muted small" style="margin-top:8px">
          - Comida roja (crece)<br>
          - Veneno violeta (pierde juego)<br>
          - Corazón amarillo (da vida extra)<br>
          - Obstáculos grises (matan)<br>
        </div>
      </div>
    </div>
  </div>
</div>

<script>

 class Particle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 2 + 1; // tamaño de partícula
        this.alpha = 1;

        // 🔹 colores aleatorios
        const colors = [
    '#ffffff', // blanco puro
    '#f0f0f0', // blanco grisáceo
    '#e6e6e6', // blanco cálido
  
];

        this.color = colors[Math.floor(Math.random() * colors.length)];

        // 🔹 dispersión circular
        const angle = Math.random() * Math.PI * 2; // ángulo 0-360°
        const speed = Math.random() * 3 + 1;       // velocidad radial
        this.speedX = Math.cos(angle) * speed;
        this.speedY = Math.sin(angle) * speed;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.alpha -= 0.02;
    }

    draw(ctx) {
        ctx.fillStyle = this.hexToRgba(this.color, this.alpha);
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }

    hexToRgba(hex, alpha) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r},${g},${b},${alpha})`;
    }
}



let particles = [];

function triggerParticles(x, y) {
    for (let i = 0; i < 350; i++) {
        particles.push(new Particle(x, y));
    }
}

function updateParticles(ctx) {
    particles.forEach((p, i) => {
        p.update();
        p.draw(ctx);
        if (p.alpha <= 0) particles.splice(i, 1);
    });
}

function triggerDust(x, y) {
    for (let i = 0; i < 3; i++) { // pocas partículas
        particles.push(new DustParticle(x, y));
    }
}

// 🔥 función para disparar partículas de fuego
function triggerFireParticles(x, y) {
    for (let i = 0; i < 350; i++) {
        particles.push(new FireParticle(x, y));
    }
}


class DustParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 2 + 1; // más pequeñas
        this.speedX = (Math.random() - 0.5) * 1.5;
        this.speedY = (Math.random() - 0.5) * 1.5;
        this.alpha = 1;
        this.color = "#99ff99"; // verde claro
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.alpha -= 0.03; // se desvanece rápido
    }

    draw(ctx) {
        ctx.fillStyle = `rgba(144, 238, 144, 0.8)${this.alpha})`; // marrón con transparencia
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class FireParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 2 + 1; // tamaño de partícula
        this.alpha = 1;

        // 🔥 colores de fuego
        const colors = ['#ff0000', '#ff4500', '#ff8c00', '#ffd700']; // rojo fuerte, rojo-naranja, naranja fuerte, amarillo
        this.color = colors[Math.floor(Math.random() * colors.length)];

        // 🔹 dispersión circular
        const angle = Math.random() * Math.PI * 2; // ángulo 0-360°
        const speed = Math.random() * 5 + 1;       // velocidad radial
        this.speedX = Math.cos(angle) * speed;
        this.speedY = Math.sin(angle) * speed;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.alpha -= 0.02;
    }

    draw(ctx) {
        ctx.fillStyle = this.hexToRgba(this.color, this.alpha);
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }

    hexToRgba(hex, alpha) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r},${g},${b},${alpha})`;
    }
}

/* -----------------------------
   GAME: Snake en Canvas (completo)
   - Menú navegable con flechas/WASD + Enter
   - 4 modos (basic,easy,normal,hard)
   - Obstáculos, veneno, corazón
   - Cambio de color cada 5 comidas (interpolación segura)
   - Controles: Flechas/WASD, Espacio pausa, Enter seleccionar
   - Todo en JS puro (sin librerías)
   ----------------------------- */

/* ---------- Configuración general ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let splashActive = true;           // Splash activo
let showPressSpaceSplash = true;   // Mostramos el texto en splash


// Responsive canvas (wide-friendly): ocupará un área grande pero manteniendo proporción
function resizeCanvas() {
  // Queremos un área wide con límite máximo:
  const maxWidth = Math.min(window.innerWidth - 0, 1400); // deja espacio para UI
  const width = Math.max(480, maxWidth);
  const aspect = 16/8;
  const height = Math.round(width / aspect);

  canvas.width = width;
  canvas.height = height;
}
resizeCanvas();
window.addEventListener('resize', () => { resizeCanvas(); engine && engine.onResize && engine.onResize(); });

/* ---------- Dificultades ---------- */
const DIFFICULTIES = [
  { name: 'Básico', speedMs: 150, numObstacles: 0, poisonChance: 0.00, extraLifeChance: 0.00 },
  { name: 'Fácil',  speedMs: 140, numObstacles: 6, poisonChance: 0.20, extraLifeChance: 0.07 },
  { name: 'Normal', speedMs: 110, numObstacles: 10, poisonChance: 0.40, extraLifeChance: 0.05 },
  { name: 'Difícil',speedMs: 95,  numObstacles: 16, poisonChance: 0.5, extraLifeChance: 0.03 },
  { name: 'Extremo',speedMs: 80,  numObstacles: 20, poisonChance: 0.65, extraLifeChance: 0.02}
];

/* ---------- Colores ---------- */
const snakeColors = [
  "#FFD700", // Dorado brillante
  "#FF0000", // Rojo fuerte
  "#FF7F00", // Naranja vivo
  "#ADFF2F", // Verde limón explosivo
  "#00FF7F", // Verde esmeralda fluorescente
  "#00BFFF", // Celeste intenso
  "#1E90FF", // Azul brillante
  "#8A2BE2", // Violeta eléctrico
  "#FF00FF", // Fucsia neón
  "#FF1493"  // Rosa fuerte
];


 // 5 colores
const foodColor = '#f43f5e'; // rojo
const poisonColor = [ "#ff4500",]; // rojo, naranja, amarillo
const heartColor = '#ffd166'; // amarillo
const obstacleColor = '#64748b';
const gridBg = '#000000';

/* ---------- Motor del juego ---------- */
const engine = {
  // grid variables
  cell: 24, cols: 30, rows: 18,

  // state
  running: false,
  inMenu: true,
  paused: false,
  gameOver: false,
  difficultyIndex: 2,
  score: 0,
  foodEaten: 0,
  lives: 1,
  colorIndex: 0,
  pausedMenu: false,
  pauseMenuIndex: 0,

  // game objects
  snake: [],
  dir: {x:1, y:0},
  nextDir: {x:1, y:0},
  food: null,
  poison: null,
  heart: null,
  obstacles: [],

  // timing
  tickMs: 110,
  tickAccumulator: 0,
  lastTime: null,

  // menu selection
  menuIndex: 2,

  // 🔹 sonidos (ahora es parte del objeto engine)
  sounds: {
    eat: new Audio('sonidos/comida.mp3') // dentro de la carpeta sonidos
},

  // 🔹 tema del fondo
  theme: "space"
};






/* ---------- Utilidades ---------- */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function randInt(max){ return Math.floor(Math.random()*max); }
function posEq(a,b){ return a.x===b.x && a.y===b.y; }
function hexToRgb(hex){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  return { r: (bigint>>16)&255, g: (bigint>>8)&255, b: bigint&255 };
}
function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
function mixHex(c1, c2, t){
  const a = hexToRgb(c1), b = hexToRgb(c2);
  return '#' + ((1<<24) + (lerp(a.r,b.r,t)<<16) + (lerp(a.g,b.g,t)<<8) + lerp(a.b,b.b,t)).toString(16).slice(1);
}

/* ---------- Initializers ---------- */
function setupGrid(){
  // choose cell size so grid fits canvas with margin
  // prefer at least 16 cells tall
  const minCell = 14;
  const maxCell = 36;
  const desiredCols = Math.floor(canvas.width / 24);
  const cell = clamp(Math.floor(canvas.width / desiredCols), minCell, maxCell);
  engine.cell = cell;
  engine.cols = Math.floor(canvas.width / cell);
  engine.rows = Math.floor(canvas.height / cell);
}
setupGrid();

const staticStars = Array.from({length:100}, () => ({
  x: Math.random() * canvas.width,
  y: Math.random() * canvas.height,
  size: Math.random() * 2 + 1
}));

const movingStars = Array.from({length:60}, () => ({
  x: Math.random() * canvas.width,
  y: Math.random() * canvas.height,
  dy: Math.random() * 0.5 + 0.2,
  size: Math.random() * 2 + 1,
  alpha: Math.random()
}));

const splashComets = Array.from({length:5}, () => ({  // 👈 cambié el nombre
  x: Math.random() * canvas.width,
  y: Math.random() * canvas.height * 0.5,
  dx: Math.random() * 5 + 2,
  dy: Math.random() * 1 - 0.5,
  length: Math.random() * 50 + 50,
  color: ['#ff0','#0ff','#f0f','#0f0','#fff'][Math.floor(Math.random()*5)]
}));


/* ---------- Core functions ---------- */
function initMenu(){
  engine.inMenu = true;
  engine.running = false;
  engine.paused = false;
  engine.gameOver = false;
  engine.menuIndex = engine.difficultyIndex;
  renderUI(); // highlight selection
}



function startNewGame(difficultyIndex){
  // set difficulty
  engine.difficultyIndex = difficultyIndex;
  const diff = DIFFICULTIES[difficultyIndex];
  engine.tickMs = diff.speedMs;
  engine.score = 0;
  engine.foodEaten = 0;
  engine.lives = 1;
  engine.colorIndex = 0;

 

  // (re)setup grid for current canvas size
  setupGrid();

  // center start position
  const startX = Math.floor(engine.cols/2);
  const startY = Math.floor(engine.rows/2);

  engine.snake = [
    {x:startX, y:startY},
    {x:startX-1, y:startY},
    {x:startX-2, y:startY}
  ];
  engine.dir = {x:1,y:0};
  engine.nextDir = {x:1,y:0};
  engine.obstacles = Array.from({length:diff.numObstacles}, () => randomFreeCell());
  engine.food = randomFreeCell();

  engine.heart = null;
  engine.lastTime = performance.now();
  engine.tickAccumulator = 0;


  engine.running = true;
  engine.inMenu = false;
  engine.paused = false;
  engine.gameOver = false;
  engine.lastTime = performance.now();
  engine.tickAccumulator = 0;
  renderUI();
}

/* pick a free cell not overlapping snake/obstacles/food/etc */
function randomFreeCell(){
  let p;
  do {
    p = { x: randInt(engine.cols), y: randInt(engine.rows) };
  } while (
    engine.snake.some(s=>posEq(s,p)) ||
    engine.obstacles.some(o=>posEq(o,p)) ||
    (engine.food && posEq(engine.food,p)) ||
    (engine.poison && posEq(engine.poison,p)) ||
    (engine.heart && posEq(engine.heart,p))
  );
  return p;
}

/* ---------- Game update logic (grid ticks) ---------- */
function tick(){
  if(!engine.running || engine.paused || engine.gameOver) return;

  // aplicar dirección
  engine.dir = engine.nextDir;
  const head = { x: engine.snake[0].x + engine.dir.x, y: engine.snake[0].y + engine.dir.y };

  // wrap-around
  if(head.x < 0) head.x = engine.cols - 1;
  if(head.x >= engine.cols) head.x = 0;
  if(head.y < 0) head.y = engine.rows - 1;
  if(head.y >= engine.rows) head.y = 0;

 // colisión con sí mismo o con obstáculos
if (engine.snake.some(s => posEq(s, head)) || engine.obstacles.some(o => posEq(o, head))) {
    engine.lives -= 1;

    if (engine.lives <= 0) {
        engine.gameOver = true;
        engine.running = false;
    } else {
        // 🔹 guardar el tamaño actual de la serpiente
        const currentLength = engine.snake.length;

        // 🔹 respawn en el centro, con mismo tamaño
        const sx = Math.floor(engine.cols / 2), sy = Math.floor(engine.rows / 2);
        engine.snake = [{ x: sx, y: sy }]; // cabeza nueva

        for (let i = 1; i < currentLength; i++) {
            engine.snake.push({ x: sx - i, y: sy }); // reconstruir hacia la izquierda
        }

        engine.dir = { x: 1, y: 0 };
        engine.nextDir = { x: 1, y: 0 };
    }

    renderUI();
    return;
}

// colisión con comida
const ateFood = engine.food && posEq(head, engine.food);


// colisión con veneno
if (engine.poison) {
    const headPxX = (head.x + 0.5) * engine.cell;
    const headPxY = (head.y + 0.5) * engine.cell;
    const dx = engine.poison.floatX - headPxX;
    const dy = engine.poison.floatY - headPxY;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist < engine.poison.radius + engine.cell / 2) {
        engine.lives -= 1;

        if (engine.lives <= 0) {
            engine.gameOver = true;
            engine.running = false;
        } else {
            // 🔹 guardar el tamaño actual de la serpiente
            const currentLength = engine.snake.length;

            // 🔹 respawn en el centro, con mismo tamaño
            const sx = Math.floor(engine.cols / 2), sy = Math.floor(engine.rows / 2);
            engine.snake = [{ x: sx, y: sy }]; // cabeza nueva

            for (let i = 1; i < currentLength; i++) {
                engine.snake.push({ x: sx - i, y: sy });
            }

            engine.dir = { x: 1, y: 0 };
            engine.nextDir = { x: 1, y: 0 };
        }

        renderUI();
        return;
    }
}



  engine.snake.unshift(head);

if (ateFood) {
    engine.sounds.eat.currentTime = 0;
    engine.sounds.eat.play().catch(e => console.log(e));
}
if (!ateFood) {
    const tail = engine.snake.pop();  //  guardás el último segmento eliminado
    // 🔹 Generar partículas de polvo en la cola
    triggerDust(
        tail.x * engine.cell + engine.cell / 2, 
        tail.y * engine.cell + engine.cell / 2
    );
}


  if(ateFood){
    engine.score++;
    engine.foodEaten++;


    // 🔥 Explosión de partículas en el centro de la celda de comida
    triggerParticles(
      engine.food.x * engine.cell + engine.cell / 2,
      engine.food.y * engine.cell + engine.cell / 2
    );

    // cada 5 comidas aumenta la velocidad y cambia color
    if(engine.score % 5 === 0){
      engine.tickMs *= 0.95;
      engine.colorIndex = (engine.colorIndex + 1) % snakeColors.length;
    }

    // respawn food
    engine.food = randomFreeCell();

 // ---------- Veneno logic ----------
const diff = DIFFICULTIES[engine.difficultyIndex];

// Generar veneno con movimiento o veneno estático dependiendo de la probabilidad
if (Math.random() < diff.poisonChance) {
    // Veneno con movimiento
    engine.poison = {
        floatX: Math.random() * (canvas.width - engine.cell) + engine.cell / 2,
        floatY: Math.random() * (canvas.height - engine.cell) + engine.cell / 2,
        dx: (Math.random() * 2 - 1) * 10.5,
        dy: (Math.random() * 2 - 1) * 10.5,
        radius: engine.cell * 0.5
    };
} else {
    // No hay veneno en este ciclo, asegúrate de que `engine.poison` esté vacío
    engine.poison = null;
}




    // ---------- Heart logic ----------
    // chance de aparecer corazón al comer
    if(!engine.heart && Math.random() < diff.extraLifeChance){
        engine.heart = {
            floatX: Math.random() * (canvas.width - engine.cell) + engine.cell/2,
            floatY: Math.random() * (canvas.height - engine.cell) + engine.cell/2,
            dx: (Math.random() * 2 - 1) * 6.5,
            dy: (Math.random() * 2 - 1) * 6.5,
            radius: engine.cell * 0.35
        };
    }

    renderUI();
}





if(engine.heart){
    // mover corazón
    engine.heart.floatX += engine.heart.dx;
    engine.heart.floatY += engine.heart.dy;

    // rebote en bordes
    if(engine.heart.floatX - engine.heart.radius < 0 || engine.heart.floatX + engine.heart.radius > canvas.width)
      engine.heart.dx *= -1;
    if(engine.heart.floatY - engine.heart.radius < 0 || engine.heart.floatY + engine.heart.radius > canvas.height)
      engine.heart.dy *= -1;

    // cambio de dirección aleatorio (1 de cada 60 ticks aprox)
    if(Math.random() < 1/60){
      engine.heart.dx = (Math.random() * 2 - 1) * 4.5;
      engine.heart.dy = (Math.random() * 2 - 1) * 4.5;
    }

    // colisión con la serpiente (cabeza)
    const headPxX = (head.x + 0.5) * engine.cell;
    const headPxY = (head.y + 0.5) * engine.cell;
    const dx = engine.heart.floatX - headPxX;
    const dy = engine.heart.floatY - headPxY;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if(dist < engine.heart.radius + engine.cell/2){
      engine.lives = Math.min(engine.lives + 1, 3);
      engine.heart = null;
      renderUI();
    }
}

if(engine.poison){
    // mover veneno
    engine.poison.floatX += engine.poison.dx;
    engine.poison.floatY += engine.poison.dy;

    // rebote en bordes
    if(engine.poison.floatX - engine.poison.radius < 0 || engine.poison.floatX + engine.poison.radius > canvas.width)
      engine.poison.dx *= -1;
    if(engine.poison.floatY - engine.poison.radius < 0 || engine.poison.floatY + engine.poison.radius > canvas.height)
      engine.poison.dy *= -1;

    // cambio de dirección aleatorio
    if(Math.random() < 1/60){
      engine.poison.dx = (Math.random() * 2 - 1) * 10.5;
      engine.poison.dy = (Math.random() * 2 - 1) * 10.5;
    }

    // disparar partículas de fuego mientras se mueve
triggerFireParticles(engine.poison.floatX, engine.poison.floatY);


    // colisión con la serpiente (cabeza)
    const headPxX = (head.x + 0.5) * engine.cell;
    const headPxY = (head.y + 0.5) * engine.cell;
    const dx = engine.poison.floatX - headPxX;
    const dy = engine.poison.floatY - headPxY;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist < engine.poison.radius + engine.cell/2) {
    engine.lives -= 1;

    if (engine.lives <= 0) {
        engine.gameOver = true;
        engine.running = false;
    } else {
        const currentLength = engine.snake.length;
        const sx = Math.floor(engine.cols / 2), sy = Math.floor(engine.rows / 2);
        engine.snake = [{ x: sx, y: sy }];

        for (let i = 1; i < currentLength; i++) {
            engine.snake.push({ x: sx - i, y: sy });
        }

        engine.dir = { x: 1, y: 0 };
        engine.nextDir = { x: 1, y: 0 };
    }

    renderUI();
    return;
}

}




}


/* ---------- Main render ---------- */
function draw(){

  // 🔹 Fondo dinámico según theme
  if (engine.theme === "space") {
  // fondo negro con sutil galaxia
  const gradient = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, 0,
    canvas.width/2, canvas.height/2, canvas.width
  );
  gradient.addColorStop(0, "#000011");
  gradient.addColorStop(1, "#000033");
  ctx.fillStyle = gradient;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // estrellas fijas
  staticStars.forEach(star => {
    ctx.fillStyle = "white";
    ctx.fillRect(star.x, star.y, star.size, star.size);
  });

  // estrellas móviles/parpadeantes
  movingStars.forEach(star => {
    star.y += star.dy;
    if(star.y > canvas.height) star.y = 0;
    star.alpha += (Math.random()-0.5) * 0.05;
    star.alpha = Math.min(Math.max(star.alpha,0.2),1);
    ctx.fillStyle = `rgba(255,255,255,${star.alpha})`;
    ctx.fillRect(star.x, star.y, star.size, star.size);
  });

  // cometas
splashComets.forEach(comet => {
    comet.x += comet.dx;
    comet.y += comet.dy;
    if(comet.x - comet.length > canvas.width || comet.y > canvas.height) {
      comet.x = -comet.length;
      comet.y = Math.random() * canvas.height * 0.5;
    }
    ctx.strokeStyle = comet.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(comet.x, comet.y);
    ctx.lineTo(comet.x - comet.length, comet.y - comet.dy*10);
    ctx.stroke();
});




  } else if (engine.theme === "nature") {
    // fondo verde natural
    const gradient = ctx.createLinearGradient(0,0,0,canvas.height);
    gradient.addColorStop(0,"#88cc66"); // verde claro
    gradient.addColorStop(1,"#335522"); // verde oscuro
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,canvas.width,canvas.height);

  } else {
    // fallback (gris)
    ctx.fillStyle = "#222";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }



  // grid (optional subtle)
  // draw obstacles
  const cell = engine.cell;
  ctx.save();
  ctx.translate(0,0);

  // Draw obstacles
  ctx.fillStyle = obstacleColor;
  engine.obstacles.forEach(o => {
    ctx.fillRect(o.x*cell, o.y*cell, cell, cell);
  });

  // Draw food (single)
  if(engine.food){
    ctx.fillStyle = foodColor;
    const cx = engine.food.x*cell + cell/2, cy = engine.food.y*cell + cell/2, r = cell*0.36;
    roundFillCircle(cx, cy, r);
  }




  // Heart
  // ---------- Draw Heart (solo) ----------
if(engine.heart){
    ctx.fillStyle = heartColor;
    ctx.beginPath();
    ctx.arc(engine.heart.floatX, engine.heart.floatY, engine.heart.radius, 0, Math.PI*2);
    ctx.fill();

  // movimiento oscilante constante
  engine.frameCount = (engine.frameCount || 0) + 1; // contador de frames

  const t = engine.frameCount / 10; // ajusta velocidad del movimiento
  const heartOscX = Math.sin(t) * 0.25; // amplitud horizontal
  const heartOscY = Math.cos(t) * 0.25; // amplitud vertical

  // calculamos posición con offset +0.5 para centrar en la celda3
  const hx = (engine.heart.x + 0.5 + heartOscX) * engine.cell;
  const hy = (engine.heart.y + 0.5 + heartOscY) * engine.cell;

  roundFillCircle(hx, hy, engine.cell * 0.28);

}

// ---------- Draw Poison (solo) ----------
if(engine.poison){
    ctx.fillStyle = poisonColor;
    ctx.beginPath();
    ctx.arc(engine.poison.floatX, engine.poison.floatY, engine.poison.radius, 0, Math.PI*2);
    ctx.fill();

    // movimiento oscilante constante
    engine.poisonFrameCount = (engine.poisonFrameCount || 0) + 1;

    const t = engine.poisonFrameCount / 10;
    const poisonOscX = Math.sin(t) * 0.25;
    const poisonOscY = Math.cos(t) * 0.25;

    const px = (engine.poison.x + 0.5 + poisonOscX) * engine.cell;
    const py = (engine.poison.y + 0.5 + poisonOscY) * engine.cell;

    roundFillCircle(px, py, engine.cell * 0.28);
}

  // Snake color interpolation: progress within 5
  const nextIdx = (engine.colorIndex + 1) % snakeColors.length;
  const t = (engine.score % 5) / 5;
  const snakeColorHex = mixHex(snakeColors[engine.colorIndex], snakeColors[nextIdx], t);

  // Draw snake
  ctx.fillStyle = snakeColorHex;
  engine.snake.forEach((seg, i) => {
    // slight rounded rect for style
    roundRect(ctx, seg.x*cell+1, seg.y*cell+1, cell-2, cell-2, Math.max(4, cell*0.12));
  });

  // Score & small HUD on canvas
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(6,6,170,38);
  ctx.fillStyle = '#ffffff';
  ctx.font = `${12 + Math.round(cell*0.06)}px monospace`;
  ctx.fillText(`Puntos: ${engine.score}`, 14, 24);
  ctx.fillText(`Vidas: ${engine.lives}`, 110, 24);

  // === Dibujar partículas SIEMPRE al final ===
updateParticles(ctx);

ctx.restore();

  // paused / menu / gameover overlay
    // ---------- Overlays ----------
  if(engine.inMenu){
    drawMenuOverlay();
  } else if(engine.pausedMenu){
    drawPauseMenuOverlay();   // 👈 nuevo
  } else if(engine.paused){
    drawCenteredText('PAUSE', 'Press P to continue');
  } else if(engine.gameOver){
  drawCenteredText('GAME OVER', 'R: Restart · Esc: Menú');
}



  ctx.restore();
}

function roundFillCircle(x,y,r){
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.fill();
}

/* ---------- Overlay / Menu rendering on canvas ---------- */
function drawMenuOverlay(){
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.font = `${Math.round(engine.cell * 1.0)}px monospace`;
  ctx.fillText('Snake — Selecciona modo', canvas.width/2, canvas.height/2 - 60);
  ctx.font = `${Math.round(engine.cell * 0.6)}px monospace`;
  for(let i=0;i<DIFFICULTIES.length;i++){
    const text = `${i===engine.menuIndex ? '▶ ' : '   '}${DIFFICULTIES[i].name}`;
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 10 + i*30);
  }
  ctx.textAlign = 'start';
}

/* ---------- Helpers UI ---------- */
function renderUI(){
  document.getElementById('scoreLabel').innerText = engine.score;
  document.getElementById('foodCount').innerText = engine.foodEaten;
  document.getElementById('livesLabel').innerText = engine.lives;
  document.getElementById('tickLabel').innerText = engine.tickMs || DIFFICULTIES[engine.difficultyIndex].speedMs;
  document.getElementById('labelMode').innerText = 'Modo: ' + DIFFICULTIES[engine.difficultyIndex].name;

  // highlight menu items
  const items = document.querySelectorAll('#menuOptions .menu-item');
  items.forEach(it => it.classList.remove('selected'));
  const sel = document.querySelector(`#menuOptions .menu-item[data-index="${engine.menuIndex}"]`);
  if(sel) sel.classList.add('selected');
}

/* ---------- Input handling (keyboard + mouse) ---------- */
const keys = {};
window.addEventListener('keydown', (e) => {
  if(keys[e.code]) return; // evitar repeticiones
  keys[e.code] = true;

 
// ---------- Escape: navega o cierra menús ----------
if(e.code === 'Escape') {
    e.preventDefault();

    if(engine.inSubMenu) { 
        // si estamos en un submenú, volvemos al menú principal
        engine.inSubMenu = false;
        renderUI();
        return;
    }

    if(engine.inMenu || engine.pausedMenu) {
        // si estamos en el menú principal de pausa, cerramos todo
        engine.inMenu = false;
        engine.pausedMenu = false;
        engine.paused = false; // reanuda el juego
        renderUI();
        return;
    }

    // si estamos en el juego sin menú abierto, abrimos menú de pausa
    engine.pausedMenu = true;
    engine.paused = true;
    engine.pauseMenuIndex = 0;
    renderUI();
}





 // ---------- Space: volver atrás en menú ----------
if (e.code === 'Space') {
    if(engine.inMenu || engine.pausedMenu){
        // simula Escape: volver al menú anterior
        exitMenu();  // tu función que maneja salir del menú
    }
    e.preventDefault();
    return;
}


  // ---------- P: pausar/reanudar ----------
  if (e.key === 'p' || e.key === 'P') {
    if(!engine.inMenu && !engine.gameOver){
      engine.paused = !engine.paused;
      renderUI();
    }
    e.preventDefault();
    return;
  }

  // ---------- R: reiniciar ----------
  if(e.key === 'r' || e.key === 'R'){
    if(engine.gameOver){
      startNewGame(engine.difficultyIndex);
    }
    e.preventDefault();
    return;
  }

  // ---------- Navegación menú principal ----------
  if(engine.inMenu){
    if(e.code === 'ArrowUp' || e.code === 'KeyW'){
      engine.menuIndex = (engine.menuIndex - 1 + DIFFICULTIES.length) % DIFFICULTIES.length;
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'ArrowDown' || e.code === 'KeyS'){
      engine.menuIndex = (engine.menuIndex + 1) % DIFFICULTIES.length;
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'Enter'){
      startNewGame(engine.menuIndex);
      e.preventDefault();
      return;
    }
  }

  // ---------- Navegación menú de pausa ----------
  if(engine.pausedMenu){
    if(e.code === 'ArrowUp' || e.code === 'KeyW'){
      engine.pauseMenuIndex = (engine.pauseMenuIndex - 1 + 3) % 3; // 3 opciones
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'ArrowDown' || e.code === 'KeyS'){
      engine.pauseMenuIndex = (engine.pauseMenuIndex + 1) % 3;
      renderUI();
      e.preventDefault();
      return;
    }
    if(e.code === 'Enter'){
      if(engine.pauseMenuIndex === 0){
        // continuar
        engine.pausedMenu = false;
        engine.paused = false;
      }
      if(engine.pauseMenuIndex === 1){
        // cambiar modo (lleva al menú principal)
        engine.pausedMenu = false;
        engine.inMenu = true;
        initMenu();
      }
      if(engine.pauseMenuIndex === 2){
        // volver al menú principal
        engine.pausedMenu = false;
        engine.inMenu = true;
        initMenu();
      }
      renderUI();
      e.preventDefault();
      return;
    }
  }

  
  // ---------- Controles dentro del juego ----------
  if(!engine.inMenu && !engine.gameOver && !engine.pausedMenu){
    if(e.code === 'ArrowLeft' || e.code === 'KeyA'){
      if(engine.dir.x !== 1) engine.nextDir = {x:-1, y:0};
    }
    if(e.code === 'ArrowRight' || e.code === 'KeyD'){
      if(engine.dir.x !== -1) engine.nextDir = {x:1, y:0};
    }
    if(e.code === 'ArrowUp' || e.code === 'KeyW'){
      if(engine.dir.y !== 1) engine.nextDir = {x:0, y:-1};
    }
    if(e.code === 'ArrowDown' || e.code === 'KeyS'){
      if(engine.dir.y !== -1) engine.nextDir = {x:0, y:1};
    }
    if(e.code === 'Enter' && engine.gameOver){
      // reinicio con misma dificultad
      startNewGame(engine.difficultyIndex);
    }
  }

}); // cierre correcto del listener


window.addEventListener('keyup', (e) => { keys[e.code] = false; });

/* ---------- Mouse / UI bindings ---------- */
document.getElementById('btnStart').addEventListener('click', () => {
  startNewGame(engine.menuIndex);
});
document.getElementById('btnTutorial').addEventListener('click', () => {
  alert('Controles: Flechas o WASD para mover, Espacio para pausar, Enter para seleccionar. Evitá el veneno y los obstáculos. ¡Suerte!');
});
document.getElementById('btnPause').addEventListener('click', () => {
  if(engine.inMenu || engine.pausedMenu) return;
  engine.paused = !engine.paused;
});
document.getElementById('btnRestart').addEventListener('click', () => {
  startNewGame(engine.difficultyIndex);
});
document.querySelectorAll('#menuOptions .menu-item').forEach(it=>{
  it.addEventListener('click', () => {
    const idx = parseInt(it.dataset.index,10);
    engine.menuIndex = idx;
    renderUI();
  });
  it.addEventListener('dblclick', () => {
    const idx = parseInt(it.dataset.index,10);
    startNewGame(idx);
  });
});

/* ---------- Game loop using requestAnimationFrame + accumulator ---------- */
function gameLoopFrame(now){
  if(!engine.lastTime) engine.lastTime = now;
  const dt = now - engine.lastTime;
  engine.lastTime = now;

  if(engine.running && !engine.paused && !engine.inMenu && !engine.gameOver){
    engine.tickAccumulator += dt;
    while(engine.tickAccumulator >= engine.tickMs){
      tick();
      engine.tickAccumulator -= engine.tickMs;
    }
  }

  draw();
  requestAnimationFrame(gameLoopFrame);
}
requestAnimationFrame(gameLoopFrame);

/* ---------- Pause Menu Overlay ---------- */
function drawPauseMenuOverlay(){
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.font = `${Math.round(engine.cell * 1.0)}px monospace`;
  ctx.fillText('PAUSA', canvas.width/2, canvas.height/2 - 60);

  const options = ['Continuar', 'Cambiar Modo', 'Volver al Menú'];
  ctx.font = `${Math.round(engine.cell * 0.6)}px monospace`;

  for(let i=0;i<options.length;i++){
    const prefix = (i===engine.pauseMenuIndex) ? '▶ ' : '   ';
    ctx.fillText(prefix + options[i], canvas.width/2, canvas.height/2 - 10 + i*30);
  }
  ctx.textAlign = 'start';
}


/* ---------- Resize handler helper for engine ---------- */
engine.onResize = function(){
  // recompute grid so things still line up
  setupGrid();
  // ensure obstacles/food are valid
  if(engine.obstacles.length === 0 && engine.running){
    const diff = DIFFICULTIES[engine.difficultyIndex];
    engine.obstacles = Array.from({length:diff.numObstacles}, () => randomFreeCell());
  }
};

/* ---------- Helper: draw centered text ---------- */
function drawCenteredText(main, sub){
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(canvas.width*0.18, canvas.height*0.38, canvas.width*0.64, canvas.height*0.22);
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.font = `${Math.round(engine.cell * 1.0)}px monospace`;
  ctx.fillText(main, canvas.width/2, canvas.height/2 - 8);
  ctx.font = `${Math.round(engine.cell * 0.5)}px monospace`;
  ctx.fillText(sub, canvas.width/2, canvas.height/2 + 20);
}

/* ---------- Boot: show menu ---------- */
initMenu();
renderUI();

/* ---------- Small polishing / safety ---------- */
// Make sure canvas is focusable for keyboard when clicked
canvas.tabIndex = 1000;
canvas.style.outline = 'none';
canvas.addEventListener('click', ()=>{ canvas.focus(); });

</script>
</body>
</html>

